{
    parserClass='run.gleam.lang.core.parser.GleamParser'
    parserUtilClass='run.gleam.lang.core.parser.GleamParserUtil'

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Gleam"
    psiImplClassSuffix="Impl"
    psiPackage="run.gleam.lang.core.psi"
    psiImplPackage="run.gleam.lang.core.psi.impl"

    elementTypeHolderClass="run.gleam.lang.core.psi.GleamTypes"
    elementTypeClass="run.gleam.lang.core.psi.GleamElementType"
    tokenTypeClass="run.gleam.lang.core.psi.GleamTokenType"

    tokens = [
        // Keywords
        AS= 'as';
        ASSERT= 'assert';
        CASE= 'case';
        CONST= 'const';
        EXTERNAL= 'external';
        FN= 'fn';
        IF= 'if';
        IMPORT= 'import';
        LET= 'let';
        OPAQUE= 'opaque';
        PUB= 'pub';
        TODO= 'todo';
        TRY= 'try';
        TYPE= 'type';
        USE= 'use';
        
        // Unofficial Tokens
        TRUE= 'True';
        FALSE= 'False';
        
        // Groupings
        LEFT_PAREN= '(';
        RIGHT_PAREN= ')';
        LEFT_SQUARE= '[';
        RIGHT_SQUARE= ']';
        LEFT_BRACE= '{';
        RIGHT_BRACE= '}';
        
        // Operators
        // Int
        PLUS= '+';
        MINUS= '-';
        STAR= '*';
        SLASH= '/';
        LESS= '<';
        GREATER= '>';
        LESS_EQUAL= '<=';
        GREATER_EQUAL= '>=';
        PERCENT= '%';
        // Float
        PLUS_DOT= '+.';
        MINUS_DOT= '-.';
        STAR_DOT= '*.';
        SLASH_DOT= '/.';
        LESS_DOT= '<.';
        GREATER_DOT= '>.';
        LESS_EQUAL_DOT= '<=.';
        GREATER_EQUAL_DOT= '>=.';
        // String
        LT_GT= '<>';
        
        // Other Punctuation
        COLON= ':';
        COMMA= ',';
        HASH= '#';
        BANG= '!';
        EQUAL= '=';
        EQUAL_EQUAL= '==';
        NOT_EQUAL= '!=';
        VBAR= '|';
        VBAR_VBAR= '||';
        AMPER_AMPER= '&&';
        LT_LT= '<<';
        GT_GT= '>>';
        PIPE= '|>';
        DOT= '.';
        R_ARROW= '->';
        L_ARROW= '<-';
        DOT_DOT= '..';

        COMMENT_NORMAL= "regexp://.*"
        COMMENT_DOC= "regexp:///.*"
        COMMENT_MODULE= "regexp:////.*"
        NAME= "regexp:[a-z_][_0-9a-z]*"
        UP_NAME= "regexp:[A-Z][0-9a-zA-Z]*"
        DISCARD_NAME= "regexp:_[_0-9a-z]*"
        ID= "<ID>"
        DECIMAL = "regexp:[0-9][0-9_]*"
        HEX = "regexp:0x[a-fA-F0-9_]*"
        OCTAL = "regexp:0o[0-7_]*"
        BINARY = "regexp:0b[01_]*"
        INTEGER = "regexp:0b[01_]*|regexp:0o[0-7_]*|regexp:0x[a-fA-F0-9_]*|regexp:[0-9] [0-9_]*"
        WHITE_SPACE = "regexp:\s+"
        STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
        FLOAT="regexp:[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)"
    ]

    generateTokenAccessors=true
}

source_file::= (statement | expression_seq | target_group)*;

// Enforce javascript | erlang with an intellij annotator
target_group::= IF (identifier) LEFT_BRACE (statement)* RIGHT_BRACE;

module ::= NAME (SLASH NAME)*;
unqualified_import
    ::= NAME (AS NAME)?
    | UP_NAME (AS UP_NAME)?
    ;
unqualified_imports
    ::= LEFT_BRACE (unqualified_import (COMMA unqualified_import)* (COMMA)?)? RIGHT_BRACE
    ;
imports
    ::= IMPORT module (DOT unqualified_imports)? (AS NAME)?
    ;

constant_function_parameter_types
    ::= LEFT_PAREN (constant_type_special (COMMA constant_type_special)* (COMMA)?)? RIGHT_PAREN;
constant_type_function
    ::= FN (constant_function_parameter_types)? R_ARROW constant_type_special
    ;

constant_tuple::= HASH LEFT_PAREN (constant_value (COMMA constant_value)* (COMMA)?)? RIGHT_PAREN;
constant_type_tuple
    ::= HASH LEFT_PAREN (constant_type_special (COMMA constant_type_special)* (COMMA)?)? RIGHT_PAREN;

constant_type_arguement::= constant_type_special;
constant_type_arguements::= LEFT_PAREN (constant_type_arguement (COMMA constant_type_arguement)* (COMMA)?)? RIGHT_PAREN;

constant_list::= LEFT_SQUARE (constant_value (COMMA constant_value )* (COMMA)?)? RIGHT_SQUARE;

constant_record_argument::= (label COLON)? constant_value;
constant_record_arguments::= LEFT_PAREN (constant_record_argument (COMMA (constant_record_argument)* (COMMA)?))? RIGHT_PAREN;
constant_record ::= (constructor_name | remote_constructor_name) (constant_record_arguments)?;

bit_string_segment_option_size ::= identifier LEFT_PAREN INTEGER RIGHT_PAREN;
// 'binary' | 'bytes' | 'int' | 'float' | 'bit_string' | 'bits' | 'utf8' | 'utf16' | 'utf32' | 'utf8_codepoint' | 'utf16_codepoint' | 'utf32_codepoint' | 'signed' | 'unsigned' | 'big' | 'little' | 'native' | 'unit' '(' INTEGER ')';
// enforce value for identifier for these surrounding 2 rules with an intelliJ annotator
bit_string_named_segment_option::= identifier | bit_string_segment_option_size;
bit_string_segment_option::= bit_string_named_segment_option | INTEGER;
bit_string_segment_options::= bit_string_segment_option (MINUS bit_string_segment_option)*  (MINUS)?;
constant_bit_string_segment::= constant_value (COLON bit_string_segment_options)?;
constant_bit_string::= LT_LT  (constant_bit_string_segment (COMMA constant_bit_string_segment)* (COMMA)?)? GT_GT;

constant_type::= (type_identifier | remote_type_identifier) (constant_type_arguements)?;
constant_type_special
    ::= type_hole
    | constant_type_tuple
    | constant_type_function
    | constant_type
    ;
constant_type_annotation::= COLON constant_type;
constant_field_access::= identifier DOT label;
constant_value::= constant_tuple | constant_list | constant_bit_string | constant_record | identifier | constant_field_access | expression_literal;
constant
    ::= (visibility_modifier)? CONST NAME (constant_type_annotation)? EQUAL constant_value
    ;

type_parameters::= LEFT_PAREN (type_parameter (COMMA type_parameter)* (COMMA)?)? RIGHT_PAREN;
type_name::= (type_identifier | remote_type_identifier) (type_parameters)?  ;
external_type::= (visibility_modifier)? EXTERNAL TYPE type_name;

function_parameter_types ::= LEFT_PAREN (type_base (COMMA type_base)* (COMMA)?)? RIGHT_PAREN;
tuple_type::= HASH LEFT_PAREN (type_base (COMMA type_base)* (COMMA)?)? RIGHT_PAREN;
function_type::= FN (function_parameter_types)? R_ARROW type_base;

type_base::= type_hole | tuple_type | function_type | type_rule | type_var;
type_annotation::= COLON type_base;
type_argument::= type_base;
type_arguments::= LEFT_PAREN (type_argument (COMMA type_argument)* (COMMA)?)? RIGHT_PAREN;
type_rule::= (type_identifier | remote_type_identifier) (type_arguments)?;

external_function_body::= STRING STRING;
external_function_parameter::= (identifier COLON)? type_base;
external_function_parameters::= LEFT_PAREN (external_function_parameter (COMMA external_function_parameter)* (COMMA)?)? RIGHT_PAREN;
external_function::= (visibility_modifier)? EXTERNAL FN identifier external_function_parameters R_ARROW type_base EQUAL external_function_body;

function_parameter_args::= labeled_discard_param | discard_param | labeled_name_param | name_param;
function_parameter::= function_parameter_args (type_annotation)?;
function_parameters::= LEFT_PAREN (function_parameter (COMMA function_parameter)* (COMMA)?)? RIGHT_PAREN;
function_body::= LEFT_BRACE (expression_seq)? RIGHT_BRACE;
function::= (visibility_modifier)? FN identifier function_parameters (R_ARROW type_base)? function_body;

list_pattern_tail::= DOT_DOT (identifier | discard)?;
list_pattern::= LEFT_SQUARE (pattern (COMMA pattern)* (COMMA)?)? (list_pattern_tail)? RIGHT_SQUARE;

pattern_bit_string_segment::= pattern (COLON bit_string_segment_options)?;
pattern_bit_string::= LT_LT (pattern_bit_string_segment (COMMA pattern_bit_string_segment)* (COMMA)?)? GT_GT;

tuple_pattern::= HASH LEFT_PAREN (pattern (COMMA pattern)* (COMMA)?)? RIGHT_PAREN;
pattern_spread::= (DOT_DOT (COMMA)?);
record_pattern_argument::= (label COLON)? pattern;
record_pattern_arguments::= LEFT_PAREN (record_pattern_argument (COMMA record_pattern_argument)* (COMMA)?)? (pattern_spread)? RIGHT_PAREN;
record_pattern::= (constructor_name | remote_constructor_name) (record_pattern_arguments)?;
pattern::= (identifier | discard | record_pattern | expression_literal | tuple_pattern | pattern_bit_string | list_pattern) (AS identifier)?;

try_rule::= TRY pattern (type_annotation)? EQUAL expression;
expression_seq::= (expression | try_rule)+;

argument::= (label ':')? (hole | expression);
arguments::= LEFT_PAREN (argument (COMMA argument)* (COMMA)?)? RIGHT_PAREN;
record::= (constructor_name | remote_constructor_name) (arguments)?;

expression_bit_string_segment::= expression_unit (COLON bit_string_segment_options)?;
expression_bit_string::= LT_LT (expression_bit_string_segment (COMMA expression_bit_string_segment)* (COMMA)?)? GT_GT;

todo_rule::= TODO (LEFT_PAREN STRING RIGHT_PAREN)?;
tuple::= HASH LEFT_PAREN (expression (COMMA expression)* (COMMA)?)? RIGHT_PAREN;
list::= LEFT_SQUARE (expression ((COMMA expression)*)? (COMMA)? ('..' expression)?)? RIGHT_SQUARE;

anonymous_function_parameter_args::= discard_param | name_param;
anonymous_function_parameter::= anonymous_function_parameter_args (type_annotation)?;
anonymous_function_parameters::= LEFT_PAREN (anonymous_function_parameter (COMMA anonymous_function_parameter)* (COMMA)?)? RIGHT_PAREN;
anonymous_function::= FN anonymous_function_parameters (R_ARROW type_rule)? function_body;

expression_group::= LEFT_BRACE expression_seq RIGHT_BRACE;

case_clause_tuple_access::= identifier DOT INTEGER;
case_clause_guard_unit::= (identifier | case_clause_tuple_access | LEFT_BRACE case_clause_guard_expression RIGHT_BRACE | constant_value) {extends=case_clause_guard_expression};
case_clause_guard_binary_operator::= VBAR_VBAR | AMPER_AMPER | EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
    | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT | GREATER_EQUAL_DOT;
self_case_clause_guard_expression ::= case_clause_guard_expression case_clause_guard_binary_operator case_clause_guard_expression {extends=case_clause_guard_expression}
case_clause_guard_expression
    ::= self_case_clause_guard_expression
    | case_clause_guard_unit;
case_clause_guard::= IF case_clause_guard_expression;
case_clause_pattern::= pattern (COMMA pattern)*  (COMMA)?;
case_clause_patterns::= case_clause_pattern (VBAR case_clause_pattern)* (VBAR)?;
case_clause::= case_clause_patterns (case_clause_guard)? R_ARROW expression;
case_clauses::= (case_clause)+;
case_subjects::= expression_seq;
case_rule::= CASE case_subjects LEFT_BRACE case_clauses RIGHT_BRACE;

use_args::= identifier | identifier COMMA use_args;
use_rule::= USE (use_args)? L_ARROW expression;

assignment::= pattern (type_annotation)? EQUAL expression;
let_rule::= LET assignment;
assert_rule::= ASSERT assignment;
negation::= BANG expression_unit;

record_update_argument::= label COLON expression;
record_update_arguments::= record_update_argument (COMMA record_update_argument)* (COMMA)?;
record_update::= (constructor_name | remote_constructor_name) LEFT_PAREN DOT_DOT expression COMMA record_update_arguments RIGHT_PAREN;

self_call_or_access ::= call_or_access call_or_access_options {extends=call_or_access}
case_call_or_access ::= case_rule call_or_access_options {extends=call_or_access}
identifier_call_or_access ::= identifier call_or_access_options {extends=call_or_access}
expression_group_call_or_access ::= identifier call_or_access_options {extends=call_or_access}
record_call_or_access ::= record DOT label {extends=call_or_access}
record_update_call_or_access ::= record_update DOT label {extends=call_or_access}
tuple_call_or_access ::= tuple DOT INTEGER {extends=call_or_access}
anonymous_function_call_or_access ::= anonymous_function arguments {extends=call_or_access}
call_or_access_options::= arguments | (DOT label) | (DOT INTEGER);

// this deviates from the treesitter spec - it is function_call + field_access + tuple_access all in one rule to avoid indirect left recursion
call_or_access
     ::= self_call_or_access
     | case_call_or_access
     | identifier_call_or_access
     | expression_group_call_or_access
     | record_call_or_access
     | record_update_call_or_access
     | tuple_call_or_access
     | anonymous_function_call_or_access

expression_literal::= STRING | INTEGER | FLOAT | TRUE | FALSE;

record_expression ::= record {extends=expression}
anonymous_function_expression ::= anonymous_function {extends=expression}
identifier_expression ::= identifier {extends=expression}
todo_expression ::= todo_rule {extends=expression}
tuple_expression ::= tuple {extends=expression}
list_expression ::= list {extends=expression}
expression_bit_string_expression ::= expression_bit_string {extends=expression}
expression_group_expression ::= expression_group {extends=expression}
case_expression ::= case_rule {extends=expression}
let_expression ::= let_rule {extends=expression}
use_expression ::= use_rule {extends=expression}
assert_expression ::= assert_rule {extends=expression}
negation_expression ::= negation {extends=expression}
record_update_expression ::= record_update {extends=expression}
call_or_access_expression ::= call_or_access {extends=expression}
expression_literal_expression ::= expression_literal {extends=expression}

expression_unit
    ::= record_expression
    | anonymous_function_expression
    | call_or_access_expression
    | todo_expression
    | tuple_expression
    | list_expression
    | expression_bit_string_expression
    | expression_group_expression
    | case_expression
    | let_expression
    | use_expression
    | assert_expression
    | negation_expression
    | record_update_expression
    | expression_literal_expression
    | identifier_expression
    {extends=expression}

eqeq_expression ::= expression EQUAL_EQUAL expression {extends=expression}
neq_expression ::= expression NOT_EQUAL expression {extends=expression}
lt_expression ::= expression LESS expression {extends=expression}
leq_expression ::= expression LESS_EQUAL expression {extends=expression}
ltf_expression ::= expression LESS_DOT expression {extends=expression}
lef_expression ::= expression LESS_EQUAL_DOT expression {extends=expression}
gt_expression ::= expression GREATER expression {extends=expression}
geq_expression ::= expression GREATER_EQUAL expression {extends=expression}
gtf_expression ::= expression GREATER_DOT expression {extends=expression}
geqf_expression ::= expression GREATER_EQUAL_DOT expression {extends=expression}
ltgt_expression ::= expression LT_GT expression {extends=expression}
pipe_expression ::= expression PIPE expression {extends=expression}
plus_expression ::= expression PLUS expression {extends=expression}
plusf_expression ::= expression PLUS_DOT expression {extends=expression}
minus_expression ::= expression MINUS expression {extends=expression}
minusf_expression ::= expression MINUS_DOT expression {extends=expression}
star_expression ::= expression STAR expression {extends=expression}
starf_expression ::= expression STAR_DOT expression {extends=expression}
slash_expression ::= expression SLASH expression {extends=expression}
shlashf_expression ::= expression SLASH_DOT expression {extends=expression}
percent_expression ::= expression PERCENT expression {extends=expression}
and_expression ::= expression AMPER_AMPER expression {extends=expression}
or_expression ::= expression VBAR_VBAR expression {extends=expression}

expression
    ::= expression_unit
    | eqeq_expression
    | neq_expression
    | lt_expression
    | leq_expression
    | ltf_expression
    | lef_expression
    | gt_expression
    | geq_expression
    | gtf_expression
    | geqf_expression
    | ltgt_expression
    | pipe_expression
    | plus_expression
    | plusf_expression
    | minus_expression
    | minusf_expression
    | star_expression
    | starf_expression
    | slash_expression
    | shlashf_expression
    | percent_expression
    | and_expression
    | or_expression

data_constructor_argument::= (label COLON)? type_base;
data_constructor_arguments::= LEFT_PAREN (data_constructor_argument (COMMA data_constructor_argument)* (COMMA)?)? RIGHT_PAREN;
data_constructor::= constructor_name (data_constructor_arguments)?;
data_constructors::= (data_constructor)+;

type_definition::= (visibility_modifier)? (opacity_modifier)? TYPE type_name LEFT_BRACE data_constructors RIGHT_BRACE;
type_alias::= (visibility_modifier)? (opacity_modifier)? TYPE type_name EQUAL type_rule;

statement
    ::= imports
    | constant
    | external_type
    | external_function
    | function
    | type_definition
    | type_alias
    ;

///// Aliases (maybe not needed by why not have them for now and we can delete later
identifier::= NAME;
constructor_name::= UP_NAME;
type_identifier::= UP_NAME;
discard::= DISCARD_NAME;
label::= NAME;
type_parameter::= NAME;
type_var::= NAME;
type_hole::= NAME;
hole::= DISCARD_NAME;
discard_param::= discard;
name_param::= identifier;
labeled_name_param::= label identifier;
labeled_discard_param::= label discard;
remote_constructor_name::= identifier DOT constructor_name;
remote_type_identifier::= identifier DOT type_identifier;
visibility_modifier::= PUB;
opacity_modifier::= OPAQUE;