{
    parserClass='run.gleam.lang.core.parser.GleamParser'
    parserUtilClass='run.gleam.lang.core.parser.GleamParserUtil'

    implements='run.gleam.lang.core.psi.ext.GleamElement'
//    extends='run.gleam.lang.core.psi.ext.GleamElementImpl'
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Gleam"
    psiImplClassSuffix="Impl"
    psiPackage="run.gleam.lang.core.psi"
    psiImplPackage="run.gleam.lang.core.psi.impl"

    elementTypeHolderClass="run.gleam.lang.core.psi.GleamTypes"
    elementTypeClass="run.gleam.lang.core.psi.GleamElementType"
    tokenTypeClass="run.gleam.lang.core.psi.GleamTokenType"

    tokens = [
        // Keywords
        AS= 'as';
        ASSERT= 'assert';
        CASE= 'case';
        CONST= 'const';
        EXTERNAL= 'external';
        FN= 'fn';
        IF= 'if';
        IMPORT= 'import';
        LET= 'let';
        OPAQUE_KW= 'opaque';
        PANIC='panic'
        PUB= 'pub';
        TODO= 'todo';
        TRY= 'try';
        TYPE= 'type';
        USE= 'use';
        
        // Unofficial Tokens
        TRUE= 'True';
        FALSE= 'False';
        
        // Groupings
        LEFT_PAREN= '(';
        RIGHT_PAREN= ')';
        LEFT_SQUARE= '[';
        RIGHT_SQUARE= ']';
        LEFT_BRACE= '{';
        RIGHT_BRACE= '}';
        
        // Operators
        // Int
        PLUS= '+';
        MINUS= '-';
        STAR= '*';
        SLASH= '/';
        LESS= '<';
        GREATER= '>';
        LESS_EQUAL= '<=';
        GREATER_EQUAL= '>=';
        PERCENT= '%';
        // Float
        PLUS_DOT= '+.';
        MINUS_DOT= '-.';
        STAR_DOT= '*.';
        SLASH_DOT= '/.';
        LESS_DOT= '<.';
        GREATER_DOT= '>.';
        LESS_EQUAL_DOT= '<=.';
        GREATER_EQUAL_DOT= '>=.';
        // String
        LT_GT= '<>';
        
        // Other Punctuation
        COLON= ':';
        COMMA= ',';
        HASH= '#';
        BANG= '!';
        EQUAL= '=';
        EQUAL_EQUAL= '==';
        NOT_EQUAL= '!=';
        VBAR= '|';
        VBAR_VBAR= '||';
        AMPER_AMPER= '&&';
        LT_LT= '<<';
        GT_GT= '>>';
        PIPE= '|>';
        DOT= '.';
        R_ARROW= '->';
        L_ARROW= '<-';
        DOT_DOT= '..';

        COMMENT_NORMAL= "regexp://.*"
        COMMENT_DOC= "regexp:///.*"
        COMMENT_MODULE= "regexp:////.*"
        DOWN_NAME= "regexp:[a-z_][_0-9a-z]*"
        UP_NAME= "regexp:[A-Z][0-9a-zA-Z]*"
        DISCARD_NAME= "regexp:_[_0-9a-z]*"
        ID= "<ID>"
        DECIMAL = "regexp:[0-9][0-9_]*"
        HEX = "regexp:0x[a-fA-F0-9_]*"
        OCTAL = "regexp:0o[0-7_]*"
        BINARY = "regexp:0b[01_]*"
        INTEGER = "regexp:0b[01_]*|0o[0-7_]*|0x[a-fA-F0-9_]*|[0-9][0-9_]*"
        WHITE_SPACE = "regexp:\s+"
        STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
        FLOAT="regexp:[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)"
    ]
    generateTokenAccessors=true

    extends("(.+expr)") = expr
    extends("(.+call_or_access)") = call_or_access

    name(".*expr")='expression'

    consumeTokenMethod("((?!.*_with_recover).*_recover)|(.*_first)|(.*expr)") = "consumeTokenFast"
}

source_file ::= (statement | expression_seq | target_group)*;

// Enforce javascript | erlang with an intellij annotator
target_group ::= IF (identifier) LEFT_BRACE (statement)* RIGHT_BRACE;

module ::= DOWN_NAME (SLASH DOWN_NAME)*;
unqualified_import
    ::= DOWN_NAME (AS DOWN_NAME)?
    | UP_NAME (AS UP_NAME)?
    ;
unqualified_imports
    ::= LEFT_BRACE <<comma_separated_list unqualified_import>>? RIGHT_BRACE { pin = 1 }
    ;
imports
    ::= IMPORT module (DOT unqualified_imports)? (AS DOWN_NAME)? { pin = 1 }
    ;

constant_function_parameter_types
    ::= LEFT_PAREN <<comma_separated_list constant_type_special>>? RIGHT_PAREN { pin = 1 };
constant_type_function
    ::= FN (constant_function_parameter_types)? R_ARROW constant_type_special
    ;

constant_tuple::= HASH LEFT_PAREN <<comma_separated_list constant_value>>? RIGHT_PAREN { pin = 2 };
constant_type_tuple
    ::= HASH LEFT_PAREN <<comma_separated_list constant_type_special>>? RIGHT_PAREN { pin = 2 };

constant_type_argument::= constant_type_special;
constant_type_arguments::= LEFT_PAREN <<comma_separated_list constant_type_argument>>? RIGHT_PAREN { pin = 1 };

constant_list::= LEFT_SQUARE <<comma_separated_list constant_value>>? RIGHT_SQUARE {pin = 1}

constant_record_argument::= (label COLON)? constant_value;
constant_record_arguments::= LEFT_PAREN <<comma_separated_list constant_record_argument>>? RIGHT_PAREN { pin = 1 };
constant_record ::= (constructor_name | remote_constructor_name) (constant_record_arguments)?;

bit_string_segment_option_size ::= identifier LEFT_PAREN INTEGER RIGHT_PAREN;
// 'binary' | 'bytes' | 'int' | 'float' | 'bit_string' | 'bits' | 'utf8' | 'utf16' | 'utf32' | 'utf8_codepoint' | 'utf16_codepoint' | 'utf32_codepoint' | 'signed' | 'unsigned' | 'big' | 'little' | 'native' | 'unit' '(' INTEGER ')';
// enforce value for identifier for these surrounding 2 rules with an intelliJ annotator
bit_string_named_segment_option::= identifier | bit_string_segment_option_size;
bit_string_segment_option::= bit_string_named_segment_option | INTEGER;
bit_string_segment_options::= bit_string_segment_option (MINUS bit_string_segment_option)*  (MINUS)?;
constant_bit_string_segment::= constant_value (COLON bit_string_segment_options)?;
constant_bit_string::= LT_LT <<comma_separated_list constant_bit_string_segment>>? GT_GT { pin = 1 };

constant_type::= (type_identifier | remote_type_identifier) (constant_type_arguments)?;
constant_type_special
    ::= type_hole
    | constant_type_tuple
    | constant_type_function
    | constant_type
    ;
constant_type_annotation::= COLON constant_type;
constant_field_access::= identifier DOT label;
constant_value::= constant_tuple | constant_list | constant_bit_string | constant_record | identifier | constant_field_access | any_literal;
constant ::= (visibility_modifier)? CONST identifier (constant_type_annotation)? EQUAL constant_value
{
    pin = "identifier"
    implements = [
        "run.gleam.lang.core.psi.ext.GleamNamedElement"
        "run.gleam.lang.core.psi.ext.GleamNameIdentifierOwner"
        "run.gleam.lang.core.psi.ext.GleamVisibilityOwner"
    ]
    extends = "run.gleam.lang.core.psi.ext.GleamStubbedNamedVisibilityElementImpl<?>"
    stubClass = "run.gleam.lang.core.stubs.GleamConstantStub"
    elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
};

type_parameters::= LEFT_PAREN <<comma_separated_list type_param>>? RIGHT_PAREN { pin = 1 };
type_name::= (type_identifier | remote_type_identifier) (type_parameters)?  ;
external_type::= TYPE type_name { pin = 1 };

function_parameter_types ::= LEFT_PAREN <<comma_separated_list type_base>>? RIGHT_PAREN { pin = 1 };
tuple_type::= HASH LEFT_PAREN <<comma_separated_list type_base>>? RIGHT_PAREN { pin = 2 };
function_type::= FN (function_parameter_types)? function_return_type { pin = 1 };

type_base::= type_rule | type_hole | tuple_type | function_type | type_var;
type_annotation::= COLON type_base;
type_argument::= type_base;
type_arguments::= LEFT_PAREN <<comma_separated_list type_argument>>? RIGHT_PAREN { pin = 1 };
type_rule::= (type_identifier | remote_type_identifier) (type_arguments)?;

external_function_body::= STRING STRING;
external_function_parameter::= (identifier COLON)? type_base;
external_function_parameters::= LEFT_PAREN <<comma_separated_list external_function_parameter>>? RIGHT_PAREN;
external_function::= FN identifier external_function_parameters R_ARROW type_base EQUAL external_function_body { pin = 'identifier' };

external_statement ::= (visibility_modifier)? EXTERNAL (external_function | external_type) { pin = "EXTERNAL" };

function_parameter_args::= labeled_discard_param | discard_param | labeled_name_param | name_param;
function_parameter::= function_parameter_args (type_annotation)?;
function_parameters::= LEFT_PAREN <<comma_separated_list function_parameter>>? RIGHT_PAREN { pin = 1 }
function_body::= LEFT_BRACE (expression_seq)? RIGHT_BRACE { pin = 1 };
function_return_type ::= R_ARROW type_base
{
    pin = 1
    extends = "run.gleam.lang.core.psi.ext.GleamStubbedElementImpl<?>"
    stubClass = "run.gleam.lang.core.stubs.GleamPlaceholderStub<?>"
    elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
}
function::= (visibility_modifier)? FN identifier function_parameters function_return_type? function_body
{
    pin = 'identifier'
    implements = [
        "run.gleam.lang.core.psi.ext.GleamNamedElement"
        "run.gleam.lang.core.psi.ext.GleamNameIdentifierOwner"
        "run.gleam.lang.core.psi.ext.GleamVisibilityOwner"
    ]
    extends = "run.gleam.lang.core.psi.ext.GleamStubbedNamedVisibilityElementImpl<?>"
    stubClass = "run.gleam.lang.core.stubs.GleamFunctionStub"
    elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
}

list_pattern_tail::= DOT_DOT (identifier | discard)?;
list_pattern::= LEFT_SQUARE <<comma_separated_list pattern>>? (list_pattern_tail)? RIGHT_SQUARE { pin = 1 };

pattern_bit_string_segment::= pattern (COLON bit_string_segment_options)?;
pattern_bit_string::= LT_LT <<comma_separated_list pattern_bit_string_segment>>? GT_GT { pin = 1 };

tuple_pattern::= HASH LEFT_PAREN <<comma_separated_list pattern>>? RIGHT_PAREN { pin = 2 };
pattern_spread::= (DOT_DOT (COMMA)?) {pin = 1};
record_pattern_argument::= (label COLON)? pattern;
record_pattern_arguments::= LEFT_PAREN <<comma_separated_list record_pattern_argument>>? (pattern_spread)? RIGHT_PAREN { pin = 1 };
record_pattern_or_identifier::= (constructor_name | (identifier remote_constructor_name_suffix?)) (record_pattern_arguments)?;
pattern::= (record_pattern_or_identifier | discard | tuple_pattern | pattern_bit_string | list_pattern | any_literal) (AS identifier)?;

try_rule::= TRY pattern (type_annotation)? EQUAL expr { pin = 1 };
expression_seq::= (expr | try_rule)+;

argument::= (label ':')? (hole | expr);
arguments::= LEFT_PAREN <<comma_separated_list argument>>? RIGHT_PAREN;

expression_bit_string_segment::= unit_expr (COLON bit_string_segment_options)?;
expression_bit_string::= LT_LT <<comma_separated_list expression_bit_string_segment>>? GT_GT { pin = 1 };

todo_rule::= TODO (LEFT_PAREN STRING RIGHT_PAREN)?;
panic_rule ::= PANIC;
tuple::= HASH LEFT_PAREN <<comma_separated_list expr>>? RIGHT_PAREN { pin = 2 }
list::= LEFT_SQUARE (<<comma_separated_list expr>> ('..' expr)?)? RIGHT_SQUARE { pin = 1 };

anonymous_function_parameter_args::= discard_param | name_param;
anonymous_function_parameter::= anonymous_function_parameter_args (type_annotation)?;
anonymous_function_parameters::= LEFT_PAREN (<<comma_separated_list anonymous_function_parameter>>)? RIGHT_PAREN;
anonymous_function::= FN anonymous_function_parameters (R_ARROW type_rule)? function_body;

expression_group::= LEFT_BRACE expression_seq RIGHT_BRACE;

case_clause_tuple_access::= identifier DOT INTEGER;
case_clause_guard_unit::= (identifier | case_clause_tuple_access | LEFT_BRACE case_clause_guard_expression RIGHT_BRACE | constant_value) {extends=case_clause_guard_expression};
case_clause_guard_binary_operator::= VBAR_VBAR | AMPER_AMPER | EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
    | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT | GREATER_EQUAL_DOT;
self_case_clause_guard_expression ::= case_clause_guard_expression case_clause_guard_binary_operator case_clause_guard_expression {extends=case_clause_guard_expression}
case_clause_guard_expression
    ::= self_case_clause_guard_expression
    | case_clause_guard_unit;
case_clause_guard::= IF case_clause_guard_expression;
case_clause_pattern::= <<comma_separated_list pattern>>;
case_clause_patterns::= case_clause_pattern (VBAR case_clause_pattern)* (VBAR)?;
case_clause::= case_clause_patterns (case_clause_guard)? R_ARROW expr;
case_clauses::= (case_clause)+;
case_subjects::= expression_seq;
case_body ::= LEFT_BRACE case_clauses RIGHT_BRACE
case_rule::= CASE case_subjects case_body { pin = 1 };

use_args::= identifier | identifier COMMA use_args;
use_rule::= USE (use_args)? L_ARROW expr { pin = 1 };

assignment::= pattern (type_annotation)? EQUAL expr;
let_rule::= LET assignment { pin = 1 };
assert_rule::= ASSERT assignment { pin = 1 };
negation::= BANG unit_expr;

record_update_argument::= label COLON expr;
record_update_arguments::= <<comma_separated_list record_update_argument>>;
record_update::= LEFT_PAREN DOT_DOT expr COMMA record_update_arguments RIGHT_PAREN;

self_call_or_access ::= call_or_access call_or_access_options
case_call_or_access ::= case_rule call_or_access_options
identifier_call_or_access ::= identifier call_or_access_options
expression_group_call_or_access ::= expression_group call_or_access_options
record_call_or_access ::= record_expr DOT label
tuple_call_or_access ::= tuple DOT INTEGER
anonymous_function_call_or_access ::= anonymous_function arguments
call_or_access_options::= arguments | (DOT label) | (DOT INTEGER);

// this deviates from the treesitter spec - it is function_call + field_access + tuple_access all in one rule to avoid indirect left recursion
call_or_access
     ::= self_call_or_access
     | case_call_or_access
     | identifier_call_or_access
     | expression_group_call_or_access
     | record_call_or_access
     | tuple_call_or_access
     | anonymous_function_call_or_access

any_literal ::= STRING | INTEGER | FLOAT | TRUE | FALSE {
    consumeTokenMethod = "consumeTokenFast"
}

private any_literal_first ::= STRING | INTEGER | FLOAT | TRUE | FALSE

record_expr ::= (constructor_name | remote_constructor_name) (arguments | record_update)?
anonymous_function_expr ::= anonymous_function
identifier_expr ::= identifier
todo_expr ::= todo_rule
panic_expr ::= panic_rule
tuple_expr ::= tuple
list_expr ::= list
expression_bit_string_expr ::= expression_bit_string
expression_group_expr ::= expression_group
case_expr ::= case_rule
let_expr ::= let_rule
use_expr ::= use_rule
assert_expr ::= assert_rule
negation_expr ::= negation
call_or_access_expr ::= call_or_access
expression_literal_expr ::= any_literal

unit_expr
    ::= record_expr
    | anonymous_function_expr
    | call_or_access_expr
    | todo_expr
    | panic_expr
    | tuple_expr
    | list_expr
    | expression_bit_string_expr
    | expression_group_expr
    | case_expr
    | let_expr
    | use_expr
    | assert_expr
    | negation_expr
    | expression_literal_expr
    | identifier_expr

eqeq_expr ::= expr EQUAL_EQUAL expr 
neq_expr ::= expr NOT_EQUAL expr 
lt_expr ::= expr LESS expr 
leq_expr ::= expr LESS_EQUAL expr 
ltf_expr ::= expr LESS_DOT expr 
lef_expr ::= expr LESS_EQUAL_DOT expr 
gt_expr ::= expr GREATER expr 
geq_expr ::= expr GREATER_EQUAL expr 
gtf_expr ::= expr GREATER_DOT expr 
geqf_expr ::= expr GREATER_EQUAL_DOT expr 
ltgt_expr ::= expr LT_GT expr 
pipe_expr ::= expr PIPE expr 
plus_expr ::= expr PLUS expr 
plusf_expr ::= expr PLUS_DOT expr 
minus_expr ::= expr MINUS expr 
minusf_expr ::= expr MINUS_DOT expr 
star_expr ::= expr STAR expr 
starf_expr ::= expr STAR_DOT expr 
slash_expr ::= expr SLASH expr 
slashf_expr ::= expr SLASH_DOT expr 
percent_expr ::= expr PERCENT expr 
and_expr ::= expr AMPER_AMPER expr 
or_expr ::= expr VBAR_VBAR expr 

// precedence groupings - each group of expressions has equal precedence
private equality_expr ::= eqeq_expr | neq_expr;
private gt_lt_expr
    ::= lt_expr
    | leq_expr
    | ltf_expr
    | lef_expr
    | gt_expr
    | gtf_expr
    | geq_expr
    | geqf_expr
private plus_minus_expr
    ::= plus_expr
    | plusf_expr
    | minus_expr
    | minusf_expr
private mul_div_mod_concat_expr
    ::= star_expr
    | starf_expr
    | slash_expr
    | slashf_expr
    | percent_expr
    | ltgt_expr

expr
    ::= unit_expr
    | or_expr
    | and_expr
    | equality_expr
    | gt_lt_expr
    | pipe_expr
    | mul_div_mod_concat_expr
    | plus_minus_expr

data_constructor_argument::= (label COLON)? type_base;
data_constructor_arguments::= LEFT_PAREN <<comma_separated_list data_constructor_argument>>? RIGHT_PAREN { pin = 1 };
data_constructor::= constructor_name (data_constructor_arguments)?;
data_constructors::= (data_constructor)+;

upper type_definition ::= LEFT_BRACE data_constructors RIGHT_BRACE {
    pin = 1
    implements = [
        "run.gleam.lang.core.psi.ext.GleamNamedElement"
        "run.gleam.lang.core.psi.ext.GleamNameIdentifierOwner"
        "run.gleam.lang.core.psi.ext.GleamVisibilityOwner"
    ]
    extends = "run.gleam.lang.core.psi.ext.GleamStubbedNamedVisibilityElementImpl<?>"
    mixin = "run.gleam.lang.core.psi.ext.GleamTypeDefinitionImplMixIn"
    stubClass = "run.gleam.lang.core.stubs.GleamTypeDefStub"
    elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
};
upper type_alias ::= EQUAL type_rule {
     pin = 1
     implements = [
         "run.gleam.lang.core.psi.ext.GleamNamedElement"
         "run.gleam.lang.core.psi.ext.GleamNameIdentifierOwner"
         "run.gleam.lang.core.psi.ext.GleamVisibilityOwner"
     ]
     extends = "run.gleam.lang.core.psi.ext.GleamStubbedNamedVisibilityElementImpl<?>"
     mixin = "run.gleam.lang.core.psi.ext.GleamTypeAliasImplMixIn"
     stubClass = "run.gleam.lang.core.stubs.GleamTypeAliasStub"
     elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
};
type_statement ::= (visibility_modifier)? (opacity_modifier)? TYPE type_name (type_definition | type_alias) {
    pin = "TYPE"
    elementType = ToBeUpped
}

statement
    ::= imports
    | constant
    | type_statement
    | external_statement
    | function
    ;

visibility_modifier::= PUB {
    extends = "run.gleam.lang.core.psi.ext.GleamStubbedElementImpl<?>"
    stubClass = "run.gleam.lang.core.stubs.GleamVisStub"
    elementTypeFactory = "run.gleam.lang.core.stubs.StubImplementationsKt.factory"
};
opacity_modifier::= OPAQUE_KW;

///// Aliases (maybe not needed by why not have them for now and we can delete later
identifier::= DOWN_NAME;
constructor_name::= UP_NAME;
type_identifier::= UP_NAME;
discard::= DISCARD_NAME;
label::= DOWN_NAME;
type_param::= DOWN_NAME;
type_var::= DOWN_NAME;
type_hole::= DOWN_NAME;
hole::= DISCARD_NAME;
discard_param::= discard;
name_param::= identifier;
labeled_name_param::= label identifier;
labeled_discard_param::= label discard;
remote_constructor_name::= identifier DOT constructor_name;
remote_constructor_name_suffix::= DOT constructor_name;
remote_type_identifier::= identifier DOT type_identifier;

//// UTILS
// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( COMMA <<param>> )* COMMA?

// Use as an `elementType` for always upped rules like `Rule ::= FOO BAR ( upper1 | upper2 )`
// (without an `elementType` upper rules won't work, GK can change element type of the frame
// only if it already has some type)
// https://github.com/JetBrains/Grammar-Kit/blob/d716ade658/src/org/intellij/grammar/parser/GeneratedParserUtilBase.java#L656
fake ToBeUpped ::=