{
    parserClass='run.gleam.lang.core.parser.GleamParser'
    parserUtilClass='run.gleam.lang.core.parser.GleamParserUtil'

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Gleam"
    psiImplClassSuffix="Impl"
    psiPackage="run.gleam.lang.core.psi"
    psiImplPackage="run.gleam.lang.core.psi.impl"

    elementTypeHolderClass="run.gleam.lang.core.psi.GleamTypes"
    elementTypeClass="run.gleam.lang.core.psi.GleamElementType"
    tokenTypeClass="run.gleam.lang.core.psi.GleamTokenType"

    tokens = [
        // Keywords
        AS= 'as';
        ASSERT= 'assert';
        CASE= 'case';
        CONST= 'const';
        EXTERNAL= 'external';
        FN= 'fn';
        IF= 'if';
        IMPORT= 'import';
        LET= 'let';
        OPAQUE_KW= 'opaque';
        PUB= 'pub';
        TODO= 'todo';
        TRY= 'try';
        TYPE= 'type';
        USE= 'use';
        
        // Unofficial Tokens
        TRUE= 'True';
        FALSE= 'False';
        
        // Groupings
        LEFT_PAREN= '(';
        RIGHT_PAREN= ')';
        LEFT_SQUARE= '[';
        RIGHT_SQUARE= ']';
        LEFT_BRACE= '{';
        RIGHT_BRACE= '}';
        
        // Operators
        // Int
        PLUS= '+';
        MINUS= '-';
        STAR= '*';
        SLASH= '/';
        LESS= '<';
        GREATER= '>';
        LESS_EQUAL= '<=';
        GREATER_EQUAL= '>=';
        PERCENT= '%';
        // Float
        PLUS_DOT= '+.';
        MINUS_DOT= '-.';
        STAR_DOT= '*.';
        SLASH_DOT= '/.';
        LESS_DOT= '<.';
        GREATER_DOT= '>.';
        LESS_EQUAL_DOT= '<=.';
        GREATER_EQUAL_DOT= '>=.';
        // String
        LT_GT= '<>';
        
        // Other Punctuation
        COLON= ':';
        COMMA= ',';
        HASH= '#';
        BANG= '!';
        EQUAL= '=';
        EQUAL_EQUAL= '==';
        NOT_EQUAL= '!=';
        VBAR= '|';
        VBAR_VBAR= '||';
        AMPER_AMPER= '&&';
        LT_LT= '<<';
        GT_GT= '>>';
        PIPE= '|>';
        DOT= '.';
        R_ARROW= '->';
        L_ARROW= '<-';
        DOT_DOT= '..';

        COMMENT_NORMAL= "regexp://.*"
        COMMENT_DOC= "regexp:///.*"
        COMMENT_MODULE= "regexp:////.*"
        DOWN_NAME= "regexp:[a-z_][_0-9a-z]*"
        UP_NAME= "regexp:[A-Z][0-9a-zA-Z]*"
        DISCARD_NAME= "regexp:_[_0-9a-z]*"
        ID= "<ID>"
        DECIMAL = "regexp:[0-9][0-9_]*"
        HEX = "regexp:0x[a-fA-F0-9_]*"
        OCTAL = "regexp:0o[0-7_]*"
        BINARY = "regexp:0b[01_]*"
        INTEGER = "regexp:0b[01_]*|regexp:0o[0-7_]*|regexp:0x[a-fA-F0-9_]*|regexp:[0-9] [0-9_]*"
        WHITE_SPACE = "regexp:\s+"
        STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
        FLOAT="regexp:[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)"
    ]
    generateTokenAccessors=true

    extends("(.+expr)") = expr
    extends("(.+call_or_access)") = call_or_access

    consumeTokenMethod("((?!.*_with_recover).*_recover)|(.*_first)|(.*expr)") = "consumeTokenFast"
}

source_file ::= (statement | expression_seq | target_group)*;

// Enforce javascript | erlang with an intellij annotator
target_group ::= IF (identifier) LEFT_BRACE (statement)* RIGHT_BRACE;

module ::= DOWN_NAME (SLASH DOWN_NAME)*;
unqualified_import
    ::= DOWN_NAME (AS DOWN_NAME)?
    | UP_NAME (AS UP_NAME)?
    ;
unqualified_imports
    ::= LEFT_BRACE <<comma_separated_list unqualified_import>>? RIGHT_BRACE
    ;
imports
    ::= IMPORT module (DOT unqualified_imports)? (AS DOWN_NAME)?
    ;

constant_function_parameter_types
    ::= LEFT_PAREN <<comma_separated_list constant_type_special>>? RIGHT_PAREN;
constant_type_function
    ::= FN (constant_function_parameter_types)? R_ARROW constant_type_special
    ;

constant_tuple::= HASH LEFT_PAREN <<comma_separated_list constant_value>>? RIGHT_PAREN;
constant_type_tuple
    ::= HASH LEFT_PAREN <<comma_separated_list constant_type_special>>? RIGHT_PAREN;

constant_type_argument::= constant_type_special;
constant_type_arguments::= LEFT_PAREN <<comma_separated_list constant_type_argument>>? RIGHT_PAREN;

constant_list::= LEFT_SQUARE <<comma_separated_list constant_value>>? RIGHT_SQUARE;

constant_record_argument::= (label COLON)? constant_value;
constant_record_arguments::= LEFT_PAREN <<comma_separated_list constant_record_argument>>? RIGHT_PAREN;
constant_record ::= (constructor_name | remote_constructor_name) (constant_record_arguments)?;

bit_string_segment_option_size ::= identifier LEFT_PAREN INTEGER RIGHT_PAREN;
// 'binary' | 'bytes' | 'int' | 'float' | 'bit_string' | 'bits' | 'utf8' | 'utf16' | 'utf32' | 'utf8_codepoint' | 'utf16_codepoint' | 'utf32_codepoint' | 'signed' | 'unsigned' | 'big' | 'little' | 'native' | 'unit' '(' INTEGER ')';
// enforce value for identifier for these surrounding 2 rules with an intelliJ annotator
bit_string_named_segment_option::= identifier | bit_string_segment_option_size;
bit_string_segment_option::= bit_string_named_segment_option | INTEGER;
bit_string_segment_options::= bit_string_segment_option (MINUS bit_string_segment_option)*  (MINUS)?;
constant_bit_string_segment::= constant_value (COLON bit_string_segment_options)?;
constant_bit_string::= LT_LT <<comma_separated_list constant_bit_string_segment>>? GT_GT;

constant_type::= (type_identifier | remote_type_identifier) (constant_type_arguments)?;
constant_type_special
    ::= type_hole
    | constant_type_tuple
    | constant_type_function
    | constant_type
    ;
constant_type_annotation::= COLON constant_type;
constant_field_access::= identifier DOT label;
constant_value::= constant_tuple | constant_list | constant_bit_string | constant_record | identifier | constant_field_access | expression_literal;
constant
    ::= (visibility_modifier)? CONST identifier (constant_type_annotation)? EQUAL constant_value
    ;

type_parameters::= LEFT_PAREN <<comma_separated_list type_parameter>>? RIGHT_PAREN;
type_name::= (type_identifier | remote_type_identifier) (type_parameters)?  ;
external_type::= (visibility_modifier)? EXTERNAL TYPE type_name;

function_parameter_types ::= LEFT_PAREN <<comma_separated_list type_base>>? RIGHT_PAREN;
tuple_type::= HASH LEFT_PAREN <<comma_separated_list type_base>>? RIGHT_PAREN;
function_type::= FN (function_parameter_types)? R_ARROW type_base;

type_base::= type_rule | type_hole | tuple_type | function_type | type_var;
type_annotation::= COLON type_base;
type_argument::= type_base;
type_arguments::= LEFT_PAREN <<comma_separated_list type_argument>>? RIGHT_PAREN;
type_rule::= (type_identifier | remote_type_identifier) (type_arguments)?;

external_function_body::= STRING STRING;
external_function_parameter::= (identifier COLON)? type_base;
external_function_parameters::= LEFT_PAREN <<comma_separated_list external_function_parameter>>? RIGHT_PAREN;
external_function::= (visibility_modifier)? EXTERNAL FN identifier external_function_parameters R_ARROW type_base EQUAL external_function_body;

function_parameter_args::= labeled_discard_param | discard_param | labeled_name_param | name_param;
function_parameter::= function_parameter_args (type_annotation)?;
function_parameters::= LEFT_PAREN <<comma_separated_list function_parameter>>? RIGHT_PAREN;
function_body::= LEFT_BRACE (expression_seq)? RIGHT_BRACE;
function::= (visibility_modifier)? FN identifier function_parameters (R_ARROW type_base)? function_body {pin=2 recoverWhile=function_recover};
private function_recover::= !(LEFT_BRACE)

list_pattern_tail::= DOT_DOT (identifier | discard)?;
list_pattern::= LEFT_SQUARE <<comma_separated_list pattern>>? (list_pattern_tail)? RIGHT_SQUARE;

pattern_bit_string_segment::= pattern (COLON bit_string_segment_options)?;
pattern_bit_string::= LT_LT <<comma_separated_list pattern_bit_string_segment>>? GT_GT;

tuple_pattern::= HASH LEFT_PAREN <<comma_separated_list pattern>>? RIGHT_PAREN;
pattern_spread::= (DOT_DOT (COMMA)?);
record_pattern_argument::= (label COLON)? pattern;
record_pattern_arguments::= LEFT_PAREN <<comma_separated_list record_pattern_argument>>? (pattern_spread)? RIGHT_PAREN;
record_pattern::= (constructor_name | remote_constructor_name) (record_pattern_arguments)?;
pattern::= (identifier | discard | record_pattern | expression_literal | tuple_pattern | pattern_bit_string | list_pattern) (AS identifier)?;

try_rule::= TRY pattern (type_annotation)? EQUAL expr;
expression_seq::= (expr | try_rule)+;

argument::= (label ':')? (hole | expr);
arguments::= LEFT_PAREN <<comma_separated_list argument>>? RIGHT_PAREN;
record::= (constructor_name | remote_constructor_name) (arguments)?;

expression_bit_string_segment::= unit_expr (COLON bit_string_segment_options)?;
expression_bit_string::= LT_LT <<comma_separated_list expression_bit_string_segment>>? GT_GT;

todo_rule::= TODO (LEFT_PAREN STRING RIGHT_PAREN)?;
tuple::= HASH LEFT_PAREN <<comma_separated_list expr>>? RIGHT_PAREN;
list::= LEFT_SQUARE (expr ((COMMA expr)*)? (COMMA)? ('..' expr)?)? RIGHT_SQUARE;

anonymous_function_parameter_args::= discard_param | name_param;
anonymous_function_parameter::= anonymous_function_parameter_args (type_annotation)?;
anonymous_function_parameters::= LEFT_PAREN (anonymous_function_parameter (COMMA anonymous_function_parameter)* (COMMA)?)? RIGHT_PAREN;
anonymous_function::= FN anonymous_function_parameters (R_ARROW type_rule)? function_body;

expression_group::= LEFT_BRACE expression_seq RIGHT_BRACE;

case_clause_tuple_access::= identifier DOT INTEGER;
case_clause_guard_unit::= (identifier | case_clause_tuple_access | LEFT_BRACE case_clause_guard_expression RIGHT_BRACE | constant_value) {extends=case_clause_guard_expression};
case_clause_guard_binary_operator::= VBAR_VBAR | AMPER_AMPER | EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
    | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT | GREATER_EQUAL_DOT;
self_case_clause_guard_expression ::= case_clause_guard_expression case_clause_guard_binary_operator case_clause_guard_expression {extends=case_clause_guard_expression}
case_clause_guard_expression
    ::= self_case_clause_guard_expression
    | case_clause_guard_unit;
case_clause_guard::= IF case_clause_guard_expression;
case_clause_pattern::= <<comma_separated_list pattern>>;
case_clause_patterns::= case_clause_pattern (VBAR case_clause_pattern)* (VBAR)?;
case_clause::= case_clause_patterns (case_clause_guard)? R_ARROW expr;
case_clauses::= (case_clause)+;
case_subjects::= expression_seq;
case_rule::= CASE case_subjects LEFT_BRACE case_clauses RIGHT_BRACE;

use_args::= identifier | identifier COMMA use_args;
use_rule::= USE (use_args)? L_ARROW expr;

assignment::= pattern (type_annotation)? EQUAL expr;
let_rule::= LET assignment;
assert_rule::= ASSERT assignment;
negation::= BANG unit_expr;

record_update_argument::= label COLON expr;
record_update_arguments::= <<comma_separated_list record_update_argument>>;
record_update::= (constructor_name | remote_constructor_name) LEFT_PAREN DOT_DOT expr COMMA record_update_arguments RIGHT_PAREN;

self_call_or_access ::= call_or_access call_or_access_options
case_call_or_access ::= case_rule call_or_access_options
identifier_call_or_access ::= identifier call_or_access_options
expression_group_call_or_access ::= identifier call_or_access_options
record_call_or_access ::= record DOT label
record_update_call_or_access ::= record_update DOT label
tuple_call_or_access ::= tuple DOT INTEGER
anonymous_function_call_or_access ::= anonymous_function arguments
call_or_access_options::= arguments | (DOT label) | (DOT INTEGER);

// this deviates from the treesitter spec - it is function_call + field_access + tuple_access all in one rule to avoid indirect left recursion
call_or_access
     ::= self_call_or_access
     | case_call_or_access
     | identifier_call_or_access
     | expression_group_call_or_access
     | record_call_or_access
     | record_update_call_or_access
     | tuple_call_or_access
     | anonymous_function_call_or_access

expression_literal::= STRING | INTEGER | FLOAT | TRUE | FALSE;

record_expr ::= record 
anonymous_function_expr ::= anonymous_function 
identifier_expr ::= identifier 
todo_expr ::= todo_rule 
tuple_expr ::= tuple 
list_expr ::= list 
expression_bit_string_expr ::= expression_bit_string 
expression_group_expr ::= expression_group 
case_expr ::= case_rule 
let_expr ::= let_rule 
use_expr ::= use_rule 
assert_expr ::= assert_rule 
negation_expr ::= negation 
record_update_expr ::= record_update 
call_or_access_expr ::= call_or_access 
expression_literal_expr ::= expression_literal 

unit_expr
    ::= record_expr
    | anonymous_function_expr
    | call_or_access_expr
    | todo_expr
    | tuple_expr
    | list_expr
    | expression_bit_string_expr
    | expression_group_expr
    | case_expr
    | let_expr
    | use_expr
    | assert_expr
    | negation_expr
    | record_update_expr
    | expression_literal_expr
    | identifier_expr
    

eqeq_expr ::= expr EQUAL_EQUAL expr 
neq_expr ::= expr NOT_EQUAL expr 
lt_expr ::= expr LESS expr 
leq_expr ::= expr LESS_EQUAL expr 
ltf_expr ::= expr LESS_DOT expr 
lef_expr ::= expr LESS_EQUAL_DOT expr 
gt_expr ::= expr GREATER expr 
geq_expr ::= expr GREATER_EQUAL expr 
gtf_expr ::= expr GREATER_DOT expr 
geqf_expr ::= expr GREATER_EQUAL_DOT expr 
ltgt_expr ::= expr LT_GT expr 
pipe_expr ::= expr PIPE expr 
plus_expr ::= expr PLUS expr 
plusf_expr ::= expr PLUS_DOT expr 
minus_expr ::= expr MINUS expr 
minusf_expr ::= expr MINUS_DOT expr 
star_expr ::= expr STAR expr 
starf_expr ::= expr STAR_DOT expr 
slash_expr ::= expr SLASH expr 
slashf_expr ::= expr SLASH_DOT expr 
percent_expr ::= expr PERCENT expr 
and_expr ::= expr AMPER_AMPER expr 
or_expr ::= expr VBAR_VBAR expr 

// precedence groupings - each group of expressions has equal precedence
private equality_expr ::= eqeq_expr | neq_expr;
private gt_lt_expr
    ::= lt_expr
    | leq_expr
    | ltf_expr
    | lef_expr
    | gt_expr
    | gtf_expr
    | geq_expr
    | geqf_expr
private plus_minus_expr
    ::= plus_expr
    | plusf_expr
    | minus_expr
    | minusf_expr
private mul_div_mod_concat_expr
    ::= star_expr
    | starf_expr
    | slash_expr
    | slashf_expr
    | percent_expr
    | ltgt_expr

expr
    ::= unit_expr
    | or_expr
    | and_expr
    | equality_expr
    | gt_lt_expr
    | pipe_expr
    | mul_div_mod_concat_expr
    | plus_minus_expr

data_constructor_argument::= (label COLON)? type_base;
data_constructor_arguments::= LEFT_PAREN <<comma_separated_list data_constructor_argument>>? RIGHT_PAREN;
data_constructor::= constructor_name (data_constructor_arguments)?;
data_constructors::= (data_constructor)+;

type_definition::= (visibility_modifier)? (opacity_modifier)? TYPE type_name LEFT_BRACE data_constructors RIGHT_BRACE;
type_alias::= (visibility_modifier)? (opacity_modifier)? TYPE type_name EQUAL type_rule;

statement
    ::= imports
    | constant
    | external_type
    | external_function
    | function
    | type_definition
    | type_alias
    ;

///// Aliases (maybe not needed by why not have them for now and we can delete later
identifier::= DOWN_NAME;
constructor_name::= UP_NAME;
type_identifier::= UP_NAME;
discard::= DISCARD_NAME;
label::= DOWN_NAME;
type_parameter::= DOWN_NAME;
type_var::= DOWN_NAME;
type_hole::= DOWN_NAME;
hole::= DISCARD_NAME;
discard_param::= discard;
name_param::= identifier;
labeled_name_param::= label identifier;
labeled_discard_param::= label discard;
remote_constructor_name::= identifier DOT constructor_name;
remote_type_identifier::= identifier DOT type_identifier;
visibility_modifier::= PUB;
opacity_modifier::= OPAQUE_KW;

//// UTILS
// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( COMMA <<param>> )* COMMA?